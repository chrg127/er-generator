%language "c++"
%define api.parser.class {ERParser}
%define api.token.constructor
%define api.value.type variant
%define parse.assert
%define parse.error verbose
%locations

%code requires
{

#include <algorithm>
#include <string>
#include <stdexcept>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>
#include "util.hpp"

/* the output for this parser is a graph. each graph node has a type, which can be one of:
 * entity, association, gerarchy and foreign key.
 * since we will operate on the graph later in this program, we must keep
 * declarations in a separate file.
 */
#include "ergraph.hpp"

struct LexContext;

}

%param { LexContext &ctx }

%code
{

/* "nearly all parsers need a context"
 * this context deals with names and the entity graph.
 * we keep a list of scopes. any time anything is declared (entity, attribute,
 * assoc, etc.), its name is put into the current scope. before defining a new name,
 * we must search through all scopes to make sure it wasn't defined before.
 * when an object is fully declared, we simply insert it into the graph. for 'object',
 * we mean anything that is declard in the outer scope (so, no attributes or primary keys).
 * references to other objects, such as those found in (foreign-key) declarations,
 * can't be resolved through this method and must be resolved be manually searching
 * the graph.
 */
struct LexContext {
    const char *cursor;
    yy::location loc;

    ERGraph graph;
    std::vector<std::unordered_map<std::string, int>> scopes;
    std::vector<Node> node_stack;
    std::vector<std::vector<int>> link_stack;
    using syntax_error = yy::ERParser::syntax_error;
    int id = 0;

public:
    /* creates a new node with no links in the current scope.
     * the node is put into an internal stack, and ater a definition, a new scope is created.
     * the next definition of a node will automatically add a link from this node to the next one.
     * to get the node and remove it from the stack, we must call enddef().
     */
    void defnode(std::string &&name, Node::Type type)
    {
        auto r = scopes.back().emplace(name, id);
        if (!r.second)
            throw syntax_error(loc, "duplicate definition of " + name);
        // add link to current node in the stack, then push the new node into the stack
        addlink(id);
        node_stack.push_back({type, std::move(name), {}, id++});
        scopes.push_back({});
    }

#define O(ename, sname) \
    void def##sname(std::string &&name) { defnode(std::move(name), Node::Type::ename); }
    NODE_TYPES(O)
#undef O

    Node enddef() { scopes.pop_back(); Node n = std::move(node_stack.back()); node_stack.pop_back(); return n; }
    void add(Node &&node) { graph[node.id] = std::move(node); }

    void addlink(int link) { node_stack.back().links.push_back(link); }
    void addlink(const std::string &name, Node::Type type) { addlink(find_node(name, type).id); }

    /* get a name for an anonymous node */
    template <typename... T>
    std::string anon(const T&... args) { return std::to_string(id) + ":" + util::concat(args...); }

    const Node & find_node(const std::string &name, Node::Type type)
    {
        for (const auto &scope : scopes) {
            // validate name
            if (auto i = scope.find(name); i != scope.end()) {
                // validate type
                auto n = graph.find(i->second);
                if (n != graph.end() && n->second.type == type)
                    return n->second;
            }
        }
        throw syntax_error(loc, "invalid reference for identifier " + name + " for type type");
    }

    // find an attribute inside the current entity
    // used by pk decls
    int find_attr(const std::string &name)
    {
        auto r = scopes.back().find(name);
        if (r != scopes.back().end())
            throw syntax_error(loc, "name " + name + "not found in current declaration");
        return r->second;
    }

    int find_attr(const std::string &attr, const std::string &ent)
    {
        auto e = find_node(ent, Node::Type::ENTITY);
        auto a = graph_find_link(graph, e, attr, Node::Type::ATTR);
        if (a == e.links.end())
            throw syntax_error(loc, attr + " is not an attribute of entity " + ent);
        return *a;
    }
};

#define M(x) std::move(x)

}

%token      end 0
%token      ENTITY "entity" NAME "name" ATTR "attr" PK "pk" FK "fk" ASSOCIATION "association" BETWEEN "between" CARD "card"
%token      GERARCHY "gerarchy" TYPE "type" PARTIAL "partial" TOTAL "total" EXCLUSIVE "exclusive" OVERLAPPED "overlapped"
%token      PARENT "parent" CHILD "child"
%token      IDENTIFIER NUMCONST
%type<int> NUMCONST
%type<std::string> IDENTIFIER gerarchy_coverage gerarchy_overlap
%type<Node> er_object entitydecl assocdecl gerarchydecl fkdecl attrdecl pkdecl carddecl gerarchy_type
%%

diagram:                { ctx.defstart("start"); } er_objects { ctx.add(ctx.enddef()); };

er_objects:             er_objects er_object { ctx.add(M($2)); }
|                       %empty;

er_object:              entitydecl
|                       assocdecl
|                       gerarchydecl
|                       fkdecl;

entitydecl:             "(" "entity"      IDENTIFIER { ctx.defent(M($3)); }   entity_fields ")"   { $$ = ctx.enddef(); };
assocdecl:              "(" "association" IDENTIFIER { ctx.defassoc(M($3)); } assoc_fields  ")"   { $$ = ctx.enddef(); };
gerarchydecl:           "(" "gerarchy"    IDENTIFIER { ctx.defger(M($3)); }   gerarchy_fields ")" { $$ = ctx.enddef(); };
fkdecl:                 "(" "fk"          IDENTIFIER { ctx.deffk(M($3)); }    fk_fields ")"       { $$ = ctx.enddef(); };

entity_fields:          entity_fields entity_field
|                       %empty
;

entity_field:           attrdecl                        { ctx.add(M($1)); }
|                       pkdecl                          { ctx.add(M($1)); }
;

assoc_fields:           assoc_fields assoc_field
|                       %empty
;

assoc_field:            between
|                       carddecl                        { ctx.add(M($1)); }
;

gerarchy_fields:        gerarchy_fields gerarchy_field
|                       %empty
;

gerarchy_field:         gerarchy_type                   { ctx.add(M($1)); }
|                       parent
|                       child;

fk_fields:              fk_fields fk_field
|                       %empty ;
fk_field:               attrref
|                       assocref;

attrdecl:               "(" attr_keyword IDENTIFIER ")"                     { ctx.defattr(M($3)); $$ = ctx.enddef(); }
pkdecl:                 "(" "pk" IDENTIFIER ")"
                        { ctx.defpk(ctx.anon("pk_", $3)); ctx.addlink(ctx.find_attr($3)); $$ = ctx.enddef(); };

between:                "(" "between" IDENTIFIER IDENTIFIER ")"             { ctx.addlink($3, Node::Type::ENTITY); ctx.addlink($4, Node::Type::ENTITY); };
carddecl:               "(" "card" IDENTIFIER NUMCONST NUMCONST ")"
                        { ctx.defcard(ctx.anon($3, "_", $4, "_", $5)); ctx.addlink($3, Node::Type::ENTITY); $$ = ctx.enddef(); };

attrref:                "(" attr_keyword IDENTIFIER IDENTIFIER ")"          { ctx.addlink(ctx.find_attr($3, $4)); };
assocref:               "(" "association" IDENTIFIER ")"                    { ctx.addlink($3, Node::Type::ASSOC); };
gerarchy_type:          "(" "type" gerarchy_coverage gerarchy_overlap ")"   { ctx.defgertype(ctx.anon("type_", $3, "_", $4)); $$ = ctx.enddef(); };
parent:                 "(" "parent" IDENTIFIER ")"                         { ctx.addlink($3, Node::Type::ENTITY); };
child:                  "(" "child" IDENTIFIER ")"                          { ctx.addlink($3, Node::Type::ENTITY); };

gerarchy_coverage:      "partial"   { $$ = "partial"; }
|                       "total"     { $$ = "total"; };
gerarchy_overlap:       "exclusive" { $$ = "exclusive"; }
|                       "overlapped" { $$ = "overlapped"; };
attr_keyword:           "attr" | "attribute";

%%

// yy::ERParser::symbol_type yy::yylex(LexContext &ctx)
// {
//     return {};
// }

