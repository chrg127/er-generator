%language "c++"
%require "3.2"
%define api.parser.class {ERParser}
%define api.token.constructor
%define api.value.type variant
%define parse.assert
%define parse.error verbose
%locations

/* pasted at the start of the header file. */
%code requires
{

#include <algorithm>
#include <string>
#include <stdexcept>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>
#include <fmt/core.h>
#include <er/util.hpp>

/* the output for this parser is a graph. each graph node has a type, which can be one of:
 * entity, association, gerarchy and foreign key.
 * since we will operate on the graph later in this program, we must keep declarations in a separate file.
 */
#include <er/ergraph.hpp>

/* used for defining names and for certain lookups. */
struct Ident {
    int id;
    Node::Type type;
};

struct LexContext;

}

/* pasted at the end of the header file */
%code provides
{

/* "nearly all parsers need a context"
 * this context deals with names and the entity graph.
 * we keep a list of scopes. any time anything is declared (entity, attribute,
 * assoc, etc.), its name is put into the current scope. before defining a new name,
 * we must search through all scopes to make sure it wasn't defined before.
 * when an object is fully declared, we simply insert it into the graph. for 'object',
 * we mean anything that is declard in the outer scope (so, no attributes or primary keys).
 * references to other objects, such as those found in (foreign-key) declarations,
 * can't be resolved through this method and must be resolved be manually searching
 * the graph.
 */
struct LexContext {
    ERGraph graph;
    std::vector<std::unordered_map<std::string, Ident>> scopes;
    std::vector<Node> node_stack;
    using syntax_error = yy::ERParser::syntax_error;
    int id = 0;

public:

    const char *cursor;
    yy::location loc;

    /* creates a new node with no links in the current scope.
     * the node is put into an internal stack, and ater a definition, a new scope is created.
     * the next definition of a node will automatically add a link from this node to the next one.
     * to get the node and remove it from the stack, we must call enddef().
     */
    void defnode(std::string &&name, Node::Type type)
    {
        auto r = scopes.back().emplace(name, Ident{id, type});
        if (!r.second)
            throw syntax_error(loc, "duplicate definition of " + name);
        // add link to current node in the stack, then push the new node into the stack
        this->addlink(id);
        node_stack.push_back({type, std::move(name), {}, id++});
        scopes.push_back({});
    }

#define O(ename, sname) \
    void def##sname(std::string &&name) { defnode(std::move(name), Node::Type::ename); }
    NODE_TYPES(O)
#undef O

    Node enddef() { scopes.pop_back(); Node n = std::move(node_stack.back()); node_stack.pop_back(); return n; }
    void add(Node &&node) { graph[node.id] = std::move(node); }

    void addlink(int link) { node_stack.back().links.push_back(link); }
    void addlink(const std::string &name, Node::Type type) { addlink(find_node(name, type)); }

    // get a name for an anonymous node
    template <typename... T>
    std::string anon(const T&... args) { return std::to_string(id) + ":" + util::concat(args...); }

    const int find_node(const std::string &name, Node::Type type)
    {
        for (const auto &scope : scopes)
            if (auto i = scope.find(name); i != scope.end() && i->second.type == type)
                return i->second.id;
        throw syntax_error(loc, "invalid reference for identifier " + name + " for type type");
    }

    // find an attribute inside the current entity. used by pk decls.
    int find_attr(const std::string &name)
    {
        auto r = scopes.back().find(name);
        if (r != scopes.back().end() && r->second.type == Node::Type::ATTR);
            return r->second.id;
        throw syntax_error(loc, "invalid reference for identifier " + name + " of type ATTRIBUTE");
    }

    // find attribute attr for entity ent. ent must be in scope, but attr may not be in scope
    // and we must find it manually through the graph. (we also suppose the entity is already fully declared).
    int find_attr(const std::string &attr, const std::string &ent)
    {
        auto e = graph.find(find_node(ent, Node::Type::ENTITY));
        if (e == graph.end())
            throw syntax_error(loc, "internal parser error");
        auto a = graph_find_link(graph, e->second, attr, Node::Type::ATTR);
        if (a == e->second.links.end())
            throw syntax_error(loc, attr + " is not an attribute of entity " + ent);
        return *a;
    }
};

}

/* pasted inside the implementation file. */
%code
{
namespace yy { ERParser::symbol_type yylex(LexContext &ctx); }
#define M(x) std::move(x)
}

%param { LexContext &ctx }

%token      END 0
%token      ENTITY "entity" ATTR "attr" PK "pk" FK "fk" ASSOCIATION "association" BETWEEN "between" CARD "card"
%token      GERARCHY "gerarchy" TYPE "type" PARTIAL "partial" TOTAL "total" EXCLUSIVE "exclusive" OVERLAPPED "overlapped"
%token      PARENT "parent" CHILD "child"
%token      IDENTIFIER NUMCONST
%type<int> NUMCONST
%type<std::string> IDENTIFIER gerarchy_coverage gerarchy_overlap
%type<Node> er_object entitydecl assocdecl gerarchydecl fkdecl attrdecl pkdecl carddecl gerarchy_type
%%

diagram:                { ctx.defstart("start"); } er_objects { ctx.add(ctx.enddef()); };

er_objects:             er_objects er_object { ctx.add(M($2)); }
|                       %empty;

er_object:              entitydecl
|                       assocdecl
|                       gerarchydecl
|                       fkdecl;

entitydecl:             "(" "entity"      IDENTIFIER { ctx.defent(M($3)); }   entity_fields ")"   { $$ = ctx.enddef(); };
assocdecl:              "(" "association" IDENTIFIER { ctx.defassoc(M($3)); } assoc_fields  ")"   { $$ = ctx.enddef(); };
gerarchydecl:           "(" "gerarchy"    IDENTIFIER { ctx.defger(M($3)); }   gerarchy_fields ")" { $$ = ctx.enddef(); };
fkdecl:                 "(" "fk"          IDENTIFIER { ctx.deffk(M($3)); }    fk_fields ")"       { $$ = ctx.enddef(); };

entity_fields:          entity_fields entity_field
|                       %empty
;

entity_field:           attrdecl                        { ctx.add(M($1)); }
|                       pkdecl                          { ctx.add(M($1)); }
;

assoc_fields:           assoc_fields assoc_field
|                       %empty
;

assoc_field:            between                         /* creates links */
|                       carddecl                        { ctx.add(M($1)); }
;

gerarchy_fields:        gerarchy_fields gerarchy_field
|                       %empty
;

gerarchy_field:         gerarchy_type                   { ctx.add(M($1)); }
|                       parent                          /* creates links */
|                       child                           /* creates links */
;

fk_fields:              fk_fields fk_field
|                       %empty
;

fk_field:               attrref                         /* creates links */
|                       assocref                        /* creates links */
;

attrdecl:               "(" "attr" IDENTIFIER ")"                           { ctx.defattr(M($3)); $$ = ctx.enddef(); }
pkdecl:                 "(" "pk" IDENTIFIER ")"
                        { ctx.defpk(ctx.anon("pk_", $3)); ctx.addlink(ctx.find_attr($3)); $$ = ctx.enddef(); };

between:                "(" "between" IDENTIFIER IDENTIFIER ")"             { ctx.addlink($3, Node::Type::ENTITY); ctx.addlink($4, Node::Type::ENTITY); };
carddecl:               "(" "card" IDENTIFIER NUMCONST NUMCONST ")"
                        { ctx.defcard(ctx.anon($3, "_", $4, "_", $5)); ctx.addlink($3, Node::Type::ENTITY); $$ = ctx.enddef(); };

attrref:                "(" "attr" IDENTIFIER IDENTIFIER ")"                { ctx.addlink(ctx.find_attr($3, $4)); };
assocref:               "(" "association" IDENTIFIER ")"                    { ctx.addlink($3, Node::Type::ASSOC); };
gerarchy_type:          "(" "type" gerarchy_coverage gerarchy_overlap ")"   { ctx.defgertype(ctx.anon("type_", $3, "_", $4)); $$ = ctx.enddef(); };
parent:                 "(" "parent" IDENTIFIER ")"                         { ctx.addlink($3, Node::Type::ENTITY); };
child:                  "(" "child" IDENTIFIER ")"                          { ctx.addlink($3, Node::Type::ENTITY); };

gerarchy_coverage:      "partial"   { $$ = "partial"; }
|                       "total"     { $$ = "total"; }
gerarchy_overlap:       "exclusive" { $$ = "exclusive"; }
|                       "overlapped" { $$ = "overlapped"; }

%%

yy::ERParser::symbol_type yy::yylex(LexContext &ctx)
{
    const char *anchor = ctx.cursor;
    ctx.loc.step();
    auto s = [&](auto func, auto&&... params) { ctx.loc.columns(ctx.cursor - anchor); return func(params..., ctx.loc); };
    const char *YYMARKER;

// begin re2c lexer
%{

re2c:yyfill:enable   = 0;
re2c:define:YYCTYPE  = "char";
re2c:define:YYCURSOR = "ctx.cursor";

// keywords
"entity"                    { return s(ERParser::make_ENTITY); }
"attr" | "attribute"        { return s(ERParser::make_ATTR); }
"pk" | "primary-key"        { return s(ERParser::make_PK); }
"fk" | "foreign-key"        { return s(ERParser::make_FK); }
"assoc" | "association"     { return s(ERParser::make_ASSOCIATION); }
"between"                   { return s(ERParser::make_BETWEEN); }
"card" | "cardinality"      { return s(ERParser::make_CARD); }
"gerarchy"                  { return s(ERParser::make_GERARCHY); }
"type"                      { return s(ERParser::make_TYPE); }
"partial"                   { return s(ERParser::make_PARTIAL); }
"total"                     { return s(ERParser::make_TOTAL); }
"exclusive"                 { return s(ERParser::make_EXCLUSIVE); }
"overlapped"                { return s(ERParser::make_OVERLAPPED); }
"parent"                    { return s(ERParser::make_PARENT); }
"child"                     { return s(ERParser::make_CHILD); }

// identifiers
[a-zA-Z] [a-zA-Z_0-9]*      { return s(ERParser::make_IDENTIFIER, std::string(anchor, ctx.cursor)); }

// integer-literals (appear in cardinalities)
[0-9]+                      { return s(ERParser::make_NUMCONST, std::stol(std::string(anchor, ctx.cursor))); }

// whitespace and comments
"\000"                      { return s(ERParser::make_END); }
"\r\n" | [\r\n]             { ctx.loc.lines();   return yylex(ctx); }
";" [^\r\n]*                {                    return yylex(ctx); }
[\t\v\b\f]                  { ctx.loc.columns(); return yylex(ctx); }

// default
.                           {
                                auto f = [](auto... s) { return ERParser::symbol_type(s...); };
                                return s(f, ERParser::token_type(ctx.cursor[-1] & 0xFF));
                            }
%}
}

void yy::ERParser::error(const location_type &l, const std::string &str)
{
    fmt::print(stderr, "{}:{}:{}-{}: {}\n", l.begin.filename ? l.begin.filename->c_str() : "(undefined)",
                                            l.begin.line, l.begin.column, l.end.column, str);
}

