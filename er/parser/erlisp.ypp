%language "c++"
%require "3.2"
%define api.parser.class {ERParser}
%define api.token.constructor
%define api.value.type variant
%define parse.assert
%define parse.error verbose
%locations

/* pasted at the start of the header file. */
%code requires
{

#include <algorithm>
#include <string>
#include <stdexcept>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>
#include <fmt/core.h>
#include <er/util.hpp>
#include <er/nodeprops.hpp>

/* the output for this parser is a graph. each graph node has a type,
 * which can be one of: entity, association, gerarchy and foreign key.
 * since we will operate on the graph later in this program, we must keep
 * declarations in a separate file.
 */
#include <er/graph.hpp>

/* used for defining names and for quickly finding type in name lookups. */
struct Ident {
    int id;
    Node::Type type;
};

struct LexContext;

}

/* pasted at the end of the header file */
%code provides
{

namespace yy { ERParser::symbol_type yylex(LexContext &ctx); }

/*
 * "nearly all parsers need a context"
 * this context deals with names and the entity graph.
 * when the start of a new node is encountered, its name and type is
 * installed into a new scope, then a new scope is created and a new node
 * is installed into the node stack. when declaring a new node, a link to
 * the new object is put inside the links of the current node in the stack,
 * before a new node is created.
 * when the declaration of a node is finished, the current scope is
 * destroyed and the node stack returns the node that was just declared.
 * the returned node is then added into the graph.
 * we keep links using an id. any time a new node is created, the id
 * increases.
 */
class LexContext {
    const char *cursor;
    yy::location loc;
    ERGraph graph;
    std::vector<std::unordered_map<std::string, Ident>> scopes;
    std::vector<Node> node_stack;
    int id = 0;

    using syntax_error = yy::ERParser::syntax_error;

public:
    explicit LexContext(const std::string &infile, const std::string &outfile, const std::string &contents)
    {
        cursor = contents.c_str();
        loc.begin.filename = &infile;
        loc.end.filename = &outfile;
    }

    // define a new node. the node is put into the stack, and has no links.
    void defnode(std::string &&name, Node::Type type)
    {
        // we only search in the current scope for duplicated definitions. this allows shadowing.
        auto r = scopes.back().emplace(name, Ident{id, type});
        if (!r.second)
            throw syntax_error(loc, "duplicate definition of " + name);
        // add link to current node in the stack, then push the new node into the stack
        this->addlink(id);
        node_stack.push_back({type, std::move(name), {}, id++});
        scopes.push_back({});
    }

#define O(ename, sname) \
    void def##sname(std::string &&name) { defnode(std::move(name), Node::Type::ename); }
    NODE_TYPES(O)
#undef O

    void start() { node_stack.push_back({Node::Type::START, "start", {}, id++}); scopes.push_back({}); }

    Node enddef() { scopes.pop_back(); Node n = std::move(node_stack.back()); node_stack.pop_back(); return n; }
    void add(Node &&node) { graph[node.id] = std::move(node); }

    void addlink(int link) { node_stack.back().links.push_back(link); }
    void addlink(const std::string &name, Node::Type type) { addlink(find_node(name, type)); }

    // get a name for an anonymous node
    template <typename... T>
    std::string anon(const T&... args) { return std::to_string(id) + "_" + util::concat(args...); }

    // define the current node into the stack as an anonymous node
    void defanon() { node_stack.back().anonymous = true; }

    int find_node(const std::string &name, Node::Type type)
    {
        for (auto scope = scopes.crbegin(); scope != scopes.crend(); ++scope)
            if (auto i = scope->find(name); i != scope->end() && i->second.type == type)
                return i->second.id;
        throw syntax_error(loc, "invalid reference for identifier " + name + " for type " + node_str(type));
    }

    // find an attribute inside the current entity. used by pk declarations.
    int find_attr_outer_scope(const std::string &name)
    {
        auto r = scopes[scopes.size()-2].find(name);
        if (r != scopes.back().end() && r->second.type == Node::Type::ATTR)
            return r->second.id;
        throw syntax_error(loc, "invalid reference for identifier " + name + " of type ATTRIBUTE");
    }

    // find attribute attr for entity ent. ent must be in scope, but attr may not be in scope
    // and we must find it manually through the graph. (we also suppose the entity is already fully declared).
    int find_attr(const std::string &attr, const std::string &ent)
    {
        auto e = graph.find(find_node(ent, Node::Type::ENTITY));
        if (e == graph.end())
            throw syntax_error(loc, "internal parser error");
        auto a = graph_find_link(graph, e->second, attr, Node::Type::ATTR);
        if (a == e->second.links.end())
            throw syntax_error(loc, attr + " is not an attribute of entity " + ent);
        return *a;
    }

    ERGraph getgraph() { return graph; }

    friend yy::ERParser::symbol_type yy::yylex(LexContext &ctx);
};

}

/* pasted inside the implementation file. */
%code
{
#define M(x) std::move(x)
}

%param { LexContext &ctx }

%token      END 0
%token      ENTITY "entity" ATTR "attr" PK "pk" FK "fk" ASSOCIATION "association" BETWEEN "between" CARD "card"
%token      GERARCHY "gerarchy" TYPE "type" PARTIAL "partial" TOTAL "total" EXCLUSIVE "exclusive" OVERLAPPED "overlapped"
%token      PARENT "parent" CHILD "child"
%token      PAREN_START "(" PAREN_END ")"
%token      IDENTIFIER CARDVALUE
%type<std::string> IDENTIFIER gerarchy_coverage gerarchy_overlap
%type<Cardinality> CARDVALUE
%type<Node> er_object entitydecl assocdecl gerarchydecl fkdecl attrdecl pkdecl carddecl gerarchy_type
%%

diagram:                { ctx.start(); } er_objects { ctx.add(ctx.enddef()); };

er_objects:             er_objects er_object { ctx.add(M($2)); }
|                       %empty
;

er_object:              entitydecl
|                       assocdecl
|                       gerarchydecl
|                       fkdecl
;

entitydecl:             "(" "entity"      IDENTIFIER { ctx.defent(M($3)); }   entity_fields ")"   { $$ = ctx.enddef(); };
assocdecl:              "(" "association" IDENTIFIER { ctx.defassoc(M($3)); } assoc_fields  ")"   { $$ = ctx.enddef(); };
gerarchydecl:           "(" "gerarchy"    IDENTIFIER { ctx.defger(M($3)); }   gerarchy_fields ")" { $$ = ctx.enddef(); };
fkdecl:                 "(" "fk"          IDENTIFIER { ctx.deffk(M($3)); }    fk_fields ")"       { $$ = ctx.enddef(); };

entity_fields:          entity_fields entity_field
|                       %empty
;

entity_field:           attrdecl                        { ctx.add(M($1)); }
|                       pkdecl                          { ctx.add(M($1)); }
;

assoc_fields:           assoc_fields assoc_field
|                       %empty
;

assoc_field:            between                         /* creates links */
|                       carddecl                        { ctx.add(M($1)); }
;

gerarchy_fields:        gerarchy_fields gerarchy_field
|                       %empty
;

gerarchy_field:         gerarchy_type                   { ctx.add(M($1)); }
|                       parent                          /* creates links */
|                       child                           /* creates links */
;

fk_fields:              fk_fields fk_field
|                       %empty
;

fk_field:               attrref                         /* creates links */
|                       assocref                        /* creates links */
;

attrdecl:               "(" "attr" IDENTIFIER { ctx.defattr(M($3)); } attr_fields ")" { $$ = ctx.enddef(); } ;

attr_fields:            attr_fields attr_field
|                       %empty
;

attr_field:             attrdecl                        { ctx.add(M($1)); }
|                       carddecl                        { ctx.add(M($1)); }
;

pkdecl:                 "(" "pk" { ctx.defpk(ctx.anon("pk")); ctx.defanon(); } pkidentlist ")" { $$ = ctx.enddef(); }

pkidentlist:            pkidentlist IDENTIFIER          { ctx.addlink(ctx.find_attr_outer_scope($2)); }
|                       IDENTIFIER                      { ctx.addlink(ctx.find_attr_outer_scope($1)); }
;

between:                "(" "between" IDENTIFIER IDENTIFIER ")"             { ctx.addlink($3, Node::Type::ENTITY); ctx.addlink($4, Node::Type::ENTITY); };
carddecl:               "(" "card" IDENTIFIER CARDVALUE ")"
                        {
                            ctx.defcard(ctx.anon("card_", $3, "_", $4.first.to_string(), "_", $4.second.to_string()));
                            ctx.defanon();
                            ctx.addlink($3, Node::Type::ENTITY);
                            $$ = ctx.enddef();
                        };

attrref:                "(" "attr" IDENTIFIER IDENTIFIER ")"                { ctx.addlink(ctx.find_attr($3, $4)); };
assocref:               "(" "association" IDENTIFIER ")"                    { ctx.addlink($3, Node::Type::ASSOC); };
gerarchy_type:          "(" "type" gerarchy_coverage gerarchy_overlap ")"   { ctx.defgertype(ctx.anon("type_", $3, "_", $4)); ctx.defanon(); $$ = ctx.enddef(); };
parent:                 "(" "parent" IDENTIFIER ")"                         { ctx.addlink($3, Node::Type::ENTITY); };
child:                  "(" "child" IDENTIFIER ")"                          { ctx.addlink($3, Node::Type::ENTITY); };

gerarchy_coverage:      "partial"   { $$ = "partial"; }
|                       "total"     { $$ = "total"; }
;

gerarchy_overlap:       "exclusive" { $$ = "exclusive"; }
|                       "overlapped" { $$ = "overlapped"; }
;

%%

yy::ERParser::symbol_type yy::yylex(LexContext &ctx)
{
    const char *anchor = ctx.cursor;
    ctx.loc.step();
    auto s = [&](auto func, auto&&... params) { ctx.loc.columns(ctx.cursor - anchor); return func(params..., ctx.loc); };
    const char *YYMARKER;

// begin re2c lexer
%{

re2c:yyfill:enable   = 0;
re2c:define:YYCTYPE  = "char";
re2c:define:YYCURSOR = "ctx.cursor";

// keywords
"entity"                    { return s(ERParser::make_ENTITY); }
"attr" | "attribute"        { return s(ERParser::make_ATTR); }
"pk" | "primary-key"        { return s(ERParser::make_PK); }
"fk" | "foreign-key"        { return s(ERParser::make_FK); }
"assoc" | "association"     { return s(ERParser::make_ASSOCIATION); }
"between"                   { return s(ERParser::make_BETWEEN); }
"card" | "cardinality"      { return s(ERParser::make_CARD); }
"gerarchy"                  { return s(ERParser::make_GERARCHY); }
"type"                      { return s(ERParser::make_TYPE); }
"partial"                   { return s(ERParser::make_PARTIAL); }
"total"                     { return s(ERParser::make_TOTAL); }
"exclusive"                 { return s(ERParser::make_EXCLUSIVE); }
"overlapped"                { return s(ERParser::make_OVERLAPPED); }
"parent"                    { return s(ERParser::make_PARENT); }
"child"                     { return s(ERParser::make_CHILD); }

// identifiers
[a-zA-Z_] [a-zA-Z_0-9-]*     { return s(ERParser::make_IDENTIFIER, std::string(anchor, ctx.cursor)); }

// cardinality syntax. accepts anything that looks like 0:1, N:N, etc.
([nN]|[0-9]+)":"([nN]|[0-9]+) { return s(ERParser::make_CARDVALUE, make_card_value(std::string(anchor, ctx.cursor))); }

// whitespace and comments
"\000"                      { return s(ERParser::make_END); }
"\r\n" | [\r\n]             { ctx.loc.lines();   return yylex(ctx); }
";" [^\r\n]*                {                    return yylex(ctx); }
[\t\v\b\f ]                 { ctx.loc.columns(); return yylex(ctx); }

// parenthesis
"("                         { return s(ERParser::make_PAREN_START); }
")"                         { return s(ERParser::make_PAREN_END); }

// default
.                           {
                                /* return s(ERParser::make_YYerror); */
                                auto f = [](auto... s) { return ERParser::symbol_type(s...); };
                                return s(f, ERParser::token_type(ctx.cursor[-1] & 0xFF));
                            }
%}
}

void yy::ERParser::error(const location_type &l, const std::string &str)
{
    fmt::print(stderr, "{}:{}:{}-{}: {}\n", l.begin.filename ? l.begin.filename->c_str() : "(undefined)",
                                            l.begin.line, l.begin.column, l.end.column, str);
}

